/**
 * Subscribe represents our "streaming" subscription protocol.
 *
 * There is only one important RPC currently which models a generic description
 * to a topic-based pub-sub system. The state store published updates as Events.
 * The majority of this file is defining those event types.
 */
syntax = "proto3";

package proto/events;

import "structs.proto";

// StateEvents
// TODO: doc
service StateEvents {
    // Susbscribe is a generic event streaming mechanism used for efficiently
    // requesting a specific result snapshot and then following updates that
    // affect that snapshot.
    // TODO: document how to handle framing events
    rpc Subscribe(SubscribeRequest) returns (stream Event) {}
}

// Topic enumerates the supported event topics.
enum Topic {
    Unknown = 0;
    ServiceHealth = 1;
    ServiceHealthConnect = 2;
}

// SubscribeRequest is the type used to initiate a streaming Subscribe RPC.
message SubscribeRequest {
    // Topic identifies the set of events the subscriber is interested in.
    Topic Topic = 1;

    // Key is a topic-specific identifier that restricts the scope of the
    // subscription to only events pertaining to that identifier. For example
    // for watching the instances of a single service, the service's name is
    // specified as the key. An empty key indicates that all events in the topic
    // are of interest.
    string Key = 2;

    // Token is the ACL token to authenticate the request. The token must have
    // sufficient privileges to read the requested information otherwise events
    // will be filtered, possibly resulting in an empty snapshot and no further
    // updates sent.
    string Token = 3;

    // Index is the raft index the subscriber has already observed up to. This
    // is zero on an initial streaming call, but then can be provided by a
    // client on subsequent re-connections such that the full snapshot doesn't
    // need to be resent if the client is up to date.
    uint64 Index = 4;
}

// Event describes a streaming update on a subscription. Events are used both to
// describe the current "snapshot" of the result as well as ongoing mutations to
// that snapshot.
message Event {
    // Topic the event was published to
    Topic Topic = 1;

    // Key is the logical identifier for the entity that was mutated.
    string Key = 2;

    // Index is the raft index at which the mutation took place. At the top
    // level of a subscription there will always be at most one Event per index.
    // If multiple events are published to the same topic in a single raft
    // transaction then the batch of events will be encoded inside a single
    // top-level event to ensure they are delivered atomically to clients.
    uint64 Index = 3;

    // Payload is the actual event content.
    oneof Payload {
        // EndOfSnapshot indicates the event stream for the initial snapshot has
        // ended. Subsequent Events delivered will be mutations to that result.
        bool EndOfSnapshot = 5;

        // EndOfEmptySnapshot indicates that the client is still up-to-date. 
        // The snapshot has ended, and was empty. The rest of the stream will be
        // individual update events. It distinguishes between "up to date, no snapshot"
        // and "snapshot contains zero events".
        bool EndOfEmptySnapshot = 6;

        // ResetStream indicates the client should re-start the Subscribe call.
        // It is used when the server can no longer correctly maintain the
        // stream, for example because the ACL permissions for the token changed
        // and the server doesn't know which previously delivered events should
        // now not be visible. Clients when receiving this must reset their
        // local copy of the state to empty and start over from index 0 to get a
        // valid snapshot again. Servers may also send this if their state store
        // is restored from a snapshot.
        bool ResetStream = 7;

        // EventBatch is a set of events. This is typically used as the payload
        // type where multiple events are emitted in a single topic and raft
        // index (e.g. transactional updates). In this case the Topic and Index
        // values of all events will match and the whole set should be delivered
        // and consumed atomically.
        EventBatch EventBatch = 8;

        // ServiceHealth is used for ServiceHealth and ServiceHealthConnect
        // topics.
        ServiceHealthUpdate ServiceHealth = 9;
    }
}

message EventBatch {
    repeated Event Events = 1;
}

// TODO:
enum CatalogOp {
    Register = 0;
    Deregister = 1;
}

message ServiceHealthUpdate {
    CatalogOp Op = 1;
    // TODO: CheckServiceNode CheckServiceNode = 2;
}
